#!/bin/bash

# ==============================================================================
#  anqfastq2 wreapper
# ==============================================================================
ver="2.0.0"

# --- Source common settings and functions -------------------------------------

# Source functions from x.funx.sh
# NOTE: 'realpath' expands symlinks by default. Thus, $xpath is always the real
#       installation path, even when this script is called by a symlink!
xpath="$(dirname "$(realpath "$0")")"
source "${xpath}"/x.funx.sh

# --- Help message -------------------------------------------------------------

read -d '' _help_anqfastq << EOM || true
The anqFASTQ script (short for Align'n'Quantify FASTQs) is a wrapper of the STAR
aligner and RSEM quantifier. It processes multiple FASTQ files in sequence by
persistently scheduling a series of transcript alignment and abundance
quantification operations that can be executed in the background on a remote
machine. By design, only BAM (not SAM) files are generated by STAR and removed
(by default) after each RSEM cycle.
 
Usage:
  anqfastq [-h | --help] [-v | --version]
  anqfastq -p | --progress [DATADIR]
  anqfastq -k | --kill
  anqfastq [-q | --quiet] [-w | --workflow] [-s | --single-end]
           [-i | --interleaved] [-a | --keep-all] [--suffix="PATTERN"] DATADIR

Positional options:
  -h | --help         Shows this help.
  -v | --version      Shows script's version.
  -p | --progress     Shows alignment and quantification progress by printing
                      the latest cycle of the latest (still possibly growing)
                      log file. If DATADIR is not specified, it searches \$PWD
                      for anqFASTQ logs.
  -k | --kill         Kills all the 'STAR' and 'RSEM' instances currently
                      running and started by the current user (i.e., \$USER).
  -q | --quiet        Disables verbose on-screen logging.
  -w | --workflow     Makes processes run in the foreground for use in pipelines.
  -s | --single-end   Single-ended (SE) reads. NOTE: non-interleaved (i.e.,
                      dual-file) PE reads is the default.
  -i | --interleaved  PE reads interleaved into a single file. Ignored when '-s'
                      option is also present.
  -a | --keep-all     Does not delete BAM files after quantification (for those
                      who have infinite storage space...).
  --suffix="PATTERN"  For dual-file PE reads, "PATTERN" should be a regex-like
                      pattern of this type
                          "leading_str(alt_1|alt_2)trailing_str",
                      specifying the two alternative suffixes used to match
                      paired FASTQs, the default being "(1|2).fastq.gz".
                      For SE reads or interleaved PE reads, it can be any text
                      string, the default being ".fastq.gz". In any case, this
                      option must be set after -s/-i flags.
  DATADIR             Path of a FASTQ-containing folder. The script assumes that
                      all the FASTQs are in the same directory, but it doesn't
                      inspect subfolders. With '-p' option, it is the path where
                      to look for anqFASTQ progress logs. In any case, this
                      argument is expected to be the last one of the list.
EOM

# --- Function definition ------------------------------------------------------

# Show alignment and quantification progress printing the tail of the latest log
function _progress_anqfastq {

    if [[ -d "$1" ]]; then
        local target_dir="$(realpath "$1")"
    else
        printf "Bad DATADIR '$1'.\n"
        exit 1 # Argument failure exit status: bad target path
    fi

    # NOTE: In the 'find' command below, the -printf "%T@ %p\n" option prints
    #       the modification timestamp followed by the filename.
    #       The '-f 2-' option in 'cut' is used to take all the fields after
    #       the first one (i.e., the timestamp) to avoid cropping possible
    #       filenames or paths with spaces.
    local latest_log="$(find "${target_dir}" -maxdepth 1 -type f \
        -iname "Z_Quant_*.log" -printf "%T@ %p\n" \
        | sort -n | tail -n 1 | cut -d " " -f 2-)"

    if [[ -n "$latest_log" ]]; then
        
        echo -e "\n${latest_log}\n"

        # Print only the last cycle in the log file by finding the penultimate
        # occurrence of the pattern "============"
        local line=$(grep -n "============" "$latest_log" \
            | cut -d ":" -f 1 | tail -n 2 | head -n 1 || [[ $? == 1 ]])
        
        # The 're_uniq.py' python script removes the highly repeated lines
        # generated by RSEM, keeping only the last ones.        
        local rep_rgx1='^Parsed [0-9]* entries$'
        local rep_rgx2='^FIN [0-9]*$'
        local rep_rgx3='^DAT [0-9]* reads left$'
        local rep_rgx4='^[0-9]* READS PROCESSED$'
        local rep_rgx5='^ROUND = [0-9]*, SUM = [0-9.]*, bChange = [0-9.]*, totNum = [0-9]*$'
        local rep_rgx="${rep_rgx1}|${rep_rgx2}|${rep_rgx3}|${rep_rgx4}|${rep_rgx5}"
        tail -n +${line} "$latest_log" \
            | tac | "${xpath}/workers/re_uniq.py" "$rep_rgx" | tac
        exit 0 # Success exit status
    else
        printf "No anqFASTQ log file found in '${target_dir}'.\n"
        exit 2 # Argument failure exit status: missing log
    fi
}

# --- Argument parsing and validity check --------------------------------------

# Default options
verbose=true
pipeline=false
paired_reads=true
dual_files=true
remove_bam=true
suffix_pattern="(1|2).fastq.gz"
se_suffix=".fastq.gz"

# Flag Regex Pattern (FRP)
frp="^-{1,2}[a-zA-Z0-9-]+"
# Suffix Regex Pattern (VRP) for dual-file PE reads
srp="^.*\(.*\|.*\).*$"

# Argument check: options
while [[ $# -gt 0 ]]; do
    if [[ "$1" =~ $frp ]]; then
        case "$1" in
            -h | --help)
                printf "%s\n" "$_help_anqfastq"
                exit 0 # Success exit status
            ;;
            -v | --version)
                _print_ver "a'n'q FASTQ" "${ver}" "FeAR"
                exit 0 # Success exit status
            ;;
            -p | --progress)
                # Cryptic one-liner meaning "$2" or $PWD if argument 2 is unset
                _progress_anqfastq "${2:-.}"
            ;;
            -k | --kill)
                k_flag="k_flag"
                while [[ -n "$k_flag" ]]; do
                    k_flag="$(pkill -15 -eu "$USER" "STAR" || [[ $? == 1 ]])"
                    if [[ -n "$k_flag" ]]; then echo "${k_flag} gracefully"; fi
                done
                k_flag="k_flag"
                while [[ -n "$k_flag" ]]; do
                    k_flag="$(pkill -15 -eu "$USER" "rsem-" \
                        || [[ $? == 1 ]])"
                    if [[ -n "$k_flag" ]]; then echo "${k_flag} gracefully"; fi
                done
                    # Update the MOTD
                    _set_motd "${xpath}/config/motd_idle" \
                        "gracefully killed" "read alignment"
                exit 0
            ;;
            -q | --quiet)
                verbose=false
                shift
            ;;
            -w | --workflow)
                pipeline=true
                shift
            ;;
            -s | --single-end)
                paired_reads=false
                shift
            ;;
            -i | --interleaved)
                dual_files=false
                shift
            ;;
            -a | --keep-all)
                remove_bam=false
                shift  
            ;;
            --suffix*)
                # Test for '=' presence
                rgx="^--suffix="
                if [[ "$1" =~ $rgx ]]; then
                    if [[ $paired_reads == true && $dual_files == true \
                        && "${1/--suffix=/}" =~ $srp ]]; then
                        suffix_pattern="${1/--suffix=/}"
                        shift
                    elif [[ ($paired_reads == false || $dual_files == false) \
                        && "${1/--suffix=/}" != "" ]]; then
                        se_suffix="${1/--suffix=/}"
                        shift
                    else
                        printf "Bad suffix pattern.\n"
                        printf "Values assigned to '--suffix' must have the "
                        printf "following structure:\n\n"
                        printf " - Non interleaved paired-end reads:\n"
                        printf "   \"leading_str(alt_1|alt_2)trailing_str\"\n\n"
                        printf " - Single-ended/interleaved paired-end reads:\n"
                        printf "   \"any_nonEmpty_str\"\n"
                        exit 3 # Bad suffix pattern format
                    fi
                else
                    printf "Values need to be assigned to '--suffix' option "
                    printf "using the '=' operator.\n"
                    printf "Use '--help' or '-h' to see the correct syntax.\n"
                    exit 4 # Bad suffix assignment
                fi
            ;;
            *)
                printf "Unrecognized option flag '$1'.\n"
                printf "Use '--help' or '-h' to see possible options.\n"
                exit 5 # Argument failure exit status: bad flag
            ;;
        esac
    else
        # The first non-FRP sequence is taken as the DATADIR argument
        target_dir="$(realpath "$1")"
        break
    fi
done

# Argument check: DATADIR target directory
if [[ -z "${target_dir:-""}" ]]; then
    printf "Missing option or DATADIR argument.\n"
    printf "Use '--help' or '-h' to see the expected syntax.\n"
    exit 6 # Argument failure exit status: missing DATADIR
elif [[ ! -d "$target_dir" ]]; then
    printf "Invalid target directory '$target_dir'.\n"
    exit 7 # Argument failure exit status: invalid DATADIR
fi

# Retrieve STAR and RSEM local paths from the 'install.paths' file
starpath="$(grep -i "$(hostname):STAR:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
starindex_path="$(grep -i "$(hostname):S_index:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
rsempath="$(grep -i "$(hostname):RSEM:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
rsemref_path="$(grep -i "$(hostname):R_ref:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"

# Check if stuff exists
if [[ -z "${starpath}" || ! -e "${starpath}/STAR" ]]; then
    printf "Couldn't find 'STAR' executable...\n"
    printf "Please, check the 'install.paths' file.\n"
    exit 8
fi
if [[ -z "${starindex_path}" || ! -e "${starindex_path}/SA" ]]; then
    printf "Couldn't find a valid 'STAR' index...\n"
    printf "Please, build one using 'STAR ... --runMode genomeGenerate ...'\n"
    printf "and check the 'install.paths' file.\n"
    exit 9
fi
if [[ -z "${rsempath}" || ! -e "${rsempath}/rsem-calculate-expression" ]]; then
    printf "Couldn't find 'rsem-calculate-expression' executable...\n"
    printf "Please, check the 'install.paths' file.\n"
    exit 10
fi
if [[ -z "${rsemref_path}" || -z "$(find "$(dirname "${rsemref_path}")" \
    -maxdepth 1 -type f -iname "$(basename "${rsemref_path}*")" \
    2> /dev/null)" ]]; then
    printf "Couldn't find a valid 'RSEM' reference...\n"
    printf "Please, build one using 'rsem-prepare-reference'\n"
    printf "and check the 'install.paths' file.\n"
    exit 11
fi

# --- Main program -------------------------------------------------------------

running_proc=$(pgrep -l "STAR|rsem-" | wc -l || [[ $? == 1 ]])
if [[ $running_proc -gt 0 ]]; then
    printf "\nSome instances of either STAR or RSEM are already running "
    printf "in the background!"
    printf "\nPlease kill them or wait for them to finish before running this "
    printf "script again...\n"
    exit 12 # Failure exit status: STAR/RSEM already running
fi

log_file="${target_dir}"/Z_Quant_"$(basename "$target_dir")"_$(_tstamp).log
_dual_log $verbose "$log_file" "-- $(_tstamp) --" \
    "anqFASTQ :: Wrapper for STAR Aligner and RSEM Quantifier :: ver.${ver}\n"

# Set the warning login message
_set_motd "${xpath}/config/motd_warn" | tee -a "$log_file"

_dual_log $verbose "$log_file" \
    "STAR found in \"${starpath}\"" \
    "STAR index found in \"${starindex_path}\"" \
    "RSEM found in \"${rsempath}\"" \
    "RSEM reference found in \"$(dirname "${rsemref_path}")\"\n" \
    "Searching '$target_dir' for FASTQs to align..."

# Select the proper library layout and prepare variables
if $paired_reads && $dual_files; then

    _dual_log $verbose "$log_file" "\nRunning in \"dual-file paired-end\" mode:"

    # Assign the suffixes to match paired FASTQs
    r_suffix="$(_explode_ORpattern "$suffix_pattern")"
    r1_suffix="$(echo "$r_suffix" | cut -d ',' -f 1)"
    r2_suffix="$(echo "$r_suffix" | cut -d ',' -f 2)"
    _dual_log $verbose "$log_file" \
        "   Suffix 1: ${r1_suffix}" \
        "   Suffix 2: ${r2_suffix}"

    extension=".*\.gz$"
    if [[ ! "$r_suffix" =~ $extension ]]; then
        _dual_log true "$log_file" \
            "\nFATAL: Only .gz-compressed FASTQs are currently supported!" \
            "Adapt '--readFilesCommand' option to handle different formats."
        exit 13 # Argument failure exit status: missing DATADIR
    fi

    # Check FASTQ pairing
    counter=0
    while IFS= read -r line
    do
        if [[ ! -e "${line}${r1_suffix}" || ! -e "${line}${r2_suffix}" ]]; then
            _dual_log true "$log_file" \
                "\nA FASTQ file is missing in the following pair:" \
                "   ${line}${r1_suffix}" \
                "   ${line}${r2_suffix}" \
                "\nAborting..."
            exit 14 # Argument failure exit status: incomplete pair
        else
            counter=$((counter+1))
        fi
    done <<< $(find "$target_dir" -maxdepth 1 -type f \
                -iname "*$r1_suffix" -o -iname "*$r2_suffix" \
                | sed -E "s/(${r1_suffix}|${r2_suffix})//" | sort -u)
    # NOTE:
    # A 'here-string' is used here because if the 'while read' loop had been
    # piped in this way
    #
    # find ... | sed ... | sort -u | while IFS= read -r line; do ... done
    #
    # the 'counter' variable would have lost its value at end of the while loop.
    # This is because pipes create SubShells, which would have made the loop
    # run on a different shell than the script. Since pipes spawn additional
    # shells, any variable you mess with in a pipe will go out of scope as soon
    # as the pipe ends!

    _dual_log $verbose "$log_file" \
        "$counter x 2 = $((counter*2)) paired FASTQ files found."

elif ! $paired_reads; then

    _dual_log $verbose "$log_file" \
        "\nRunning in \"single-ended\" mode:" \
        "   Suffix: ${se_suffix}"

    extension=".*\.gz$"
    if [[ ! "$se_suffix" =~ $extension ]]; then
        _dual_log true "$log_file" \
            "\nFATAL: Only .gz-compressed FASTQs are currently supported!" \
            "Adapt '--readFilesCommand' option to handle different formats."
        exit 15 # Argument failure exit status: missing DATADIR
    fi

    counter=$(find "$target_dir" -maxdepth 1 -type f -iname "*${se_suffix}" | wc -l)

    if (( counter > 0 )); then
        _dual_log $verbose "$log_file" \
            "$counter single-ended FASTQ files found."
    else
        _dual_log true "$log_file" \
            "\nNo FASTQ files ending with \"${se_suffix}\" in ${target_dir}."
        exit 16 # Argument failure exit status: no FASTQ found
    fi

elif ! $dual_files; then

    _dual_log true "$log_file" \
        "\nSTAR doesn't currently support PE interleaved FASTQ files." \
        "Check it out at https://github.com/alexdobin/STAR/issues/686" \
        "You can deinterlace them first and then run x.FASTQ in the" \
        "dual-file PE default mode. See, e.g.," \
        "\nPosts" \
        "  https://stackoverflow.com/questions/59633038/how-to-split-paired-end-fastq-files" \
        "  https://www.biostars.org/p/141256/" \
        "\ndeinterleave_fastq.sh on GitHub Gist" \
        "  https://gist.github.com/nathanhaigh/3521724" \
        "\nseqfu deinterleave" \
        "  https://telatin.github.io/seqfu2/tools/deinterleave.html"
        exit 111
fi

# Export variables needed by starsem script (running in a subshell)
export	xpath paired_reads dual_files target_dir r1_suffix r2_suffix se_suffix \
        counter starpath starindex_path rsempath rsemref_path  remove_bam \
        verbose log_file

# MAIN STATEMENT
_hold_on "$log_file" "${xpath}/starsem.sh"
