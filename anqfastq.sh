#!/bin/bash

# ==============================================================================
#  Align transcripts and quantify abundances using STAR and RSEM
# ==============================================================================
ver="2.0.0"

# --- Source common settings and functions -------------------------------------
# NOTE: 'realpath' expands symlinks by default. Thus, $xpath is always the real
#       installation path, even when this script is called by a symlink!
xpath="$(dirname "$(realpath "$0")")"
source "${xpath}"/workers/x.funx.sh
source "${xpath}"/workers/progress_funx.sh

# --- Help message -------------------------------------------------------------

read -d '' _help_anqfastq << EOM || true
anqFASTQ (short for Align'n'Quantify FASTQs) is a wrapper of the STAR aligner
and RSEM quantifier designed to process multiple FASTQ files in sequence by
scheduling a series of transcript alignment and abundance quantification steps.
To make the job suitable for execution on a remote machine, processes are by
default run with persistence (i.e., ignoring the hangup signal HUP) and in the
background. By design, only BAM (not SAM) files are generated by STAR and
removed (by default) after each RSEM cycle.

Usage:
  anqfastq [-h | --help] [-v | --version]
  anqfastq -p | --progress [DATADIR]
  anqfastq -k | --kill
  anqfastq [-q | --quiet] [-w | --workflow] [-s | --single-end]
           [-i | --interleaved] [-a | --keep-all] [--suffix="PATTERN"] DATADIR

Positional options:
  -h | --help         Shows this help.
  -v | --version      Shows script's version.
  -p | --progress     Shows alignment and quantification progress by printing
                      the latest cycle of the latest (possibly growing) log
                      file. If DATADIR is not specified, it searches \$PWD for
                      anqFASTQ logs.
  -k | --kill         Gracefully (-15) kills all the 'STAR' and 'RSEM' instances
                      currently running and started by the current user.
  -q | --quiet        Disables verbose on-screen logging.
  -w | --workflow     Makes processes run in the foreground for use in pipelines.
  -s | --single-end   Single-ended (SE) reads. NOTE: non-interleaved (i.e.,
                      dual-file) PE reads is the default.
  -i | --interleaved  PE reads interleaved into a single file. Ignored when '-s'
                      option is also present.
  -a | --keep-all     Does not delete BAM files after quantification (for people
                      who have unlimited storage space...)
  --suffix="PATTERN"  For dual-file PE reads, "PATTERN" should be a regex-like
                      pattern of this type
                          "leading_str(alt_1|alt_2)trailing_str",
                      specifying the two alternative suffixes used to match
                      paired FASTQs, the default being "(1|2).fastq.gz".
                      For SE reads or interleaved PE reads, it can be any text
                      string, the default being ".fastq.gz". In any case, this
                      option must be set after -s/-i flags.
  DATADIR             Path of a FASTQ-containing folder. The script assumes that
                      all the FASTQs are in the same directory, but it doesn't
                      inspect subfolders. Placed right after '-p' option, it is
                      the path where to look for anqFASTQ progress logs.
EOM

# --- Argument parsing and validity check --------------------------------------

# Default options
verbose=true
pipeline=false
paired_reads=true
dual_files=true
remove_bam=true
suffix_pattern="(1|2).fastq.gz"
se_suffix=".fastq.gz"

# Flag Regex Pattern (FRP)
frp="^-{1,2}[a-zA-Z0-9-]+"
# Suffix Regex Pattern (SRP) for dual-file PE reads
srp="^.*\(.*\|.*\).*$"

# Argument check: options
while [[ $# -gt 0 ]]; do
    if [[ "$1" =~ $frp ]]; then
        case "$1" in
            -h | --help)
                printf "%s\n" "$_help_anqfastq"
                exit 0 # Success exit status
            ;;
            -v | --version)
                _print_ver "a'n'q FASTQ" "${ver}" "FeAR"
                exit 0 # Success exit status
            ;;
            -p | --progress)
                # Cryptic one-liner meaning "$2" or $PWD if argument 2 is unset
                _progress_anqfastq "${2:-.}"
            ;;
            -k | --kill)
                k_flag="k_flag"
                while [[ -n "$k_flag" ]]; do
                    k_flag="$(pkill -15 -eu "$USER" "STAR" || [[ $? == 1 ]])"
                    if [[ -n "$k_flag" ]]; then echo "${k_flag} gracefully"; fi
                done
                k_flag="k_flag"
                while [[ -n "$k_flag" ]]; do
                    k_flag="$(pkill -15 -eu "$USER" "rsem-" || [[ $? == 1 ]])"
                    if [[ -n "$k_flag" ]]; then echo "${k_flag} gracefully"; fi
                done
                # Update the MOTD
                _set_motd "${xpath}/config/motd_idle" \
                    "gracefully killed" "read alignment"
                exit 0
            ;;
            -q | --quiet)
                verbose=false
                shift
            ;;
            -w | --workflow)
                pipeline=true
                shift
            ;;
            -s | --single-end)
                paired_reads=false
                shift
            ;;
            -i | --interleaved)
                dual_files=false
                shift
            ;;
            -a | --keep-all)
                remove_bam=false
                shift  
            ;;
            --suffix*)
                # Test for '=' presence
                rgx="^--suffix="
                if [[ "$1" =~ $rgx ]]; then
                    if [[ $paired_reads == true && $dual_files == true \
                        && "${1/--suffix=/}" =~ $srp ]]; then
                        suffix_pattern="${1/--suffix=/}"
                        shift
                    elif [[ ($paired_reads == false || $dual_files == false) \
                        && "${1/--suffix=/}" != "" ]]; then
                        se_suffix="${1/--suffix=/}"
                        shift
                    else
                        printf "Bad suffix pattern.\n"
                        printf "Values assigned to '--suffix' must have the "
                        printf "following structure:\n\n"
                        printf " - Non interleaved paired-end reads:\n"
                        printf "   \"leading_str(alt_1|alt_2)trailing_str\"\n\n"
                        printf " - Single-ended/interleaved paired-end reads:\n"
                        printf "   \"any_nonEmpty_str\"\n"
                        exit 3 # Bad suffix pattern format
                    fi
                else
                    printf "Values need to be assigned to '--suffix' option "
                    printf "using the '=' operator.\n"
                    printf "Use '--help' or '-h' to see the correct syntax.\n"
                    exit 4 # Bad suffix assignment
                fi
            ;;
            *)
                printf "Unrecognized option flag '$1'.\n"
                printf "Use '--help' or '-h' to see possible options.\n"
                exit 5 # Argument failure exit status: bad flag
            ;;
        esac
    else
        # The first non-FRP sequence is taken as the DATADIR argument
        target_dir="$(realpath "$1")"
        shift
    fi
done

# Argument check: DATADIR target directory
_check_target_dir "${target_dir:-}"

# Retrieve STAR and RSEM local paths from the 'install.paths' file
starpath="$(grep -i "$(hostname):STAR:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
starindex_path="$(grep -i "$(hostname):S_index:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
rsempath="$(grep -i "$(hostname):RSEM:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"
rsemref_path="$(grep -i "$(hostname):R_ref:" \
    "${xpath}/config/install.paths" | cut -d ':' -f 3 || [[ $? == 1 ]])"

# Check if stuff exists
if [[ -z "${starpath}" || ! -e "${starpath}/STAR" ]]; then
    printf "Couldn't find 'STAR' executable...\n"
    printf "Please, check the 'install.paths' file.\n"
    exit 8
fi
if [[ -z "${starindex_path}" || ! -e "${starindex_path}/SA" ]]; then
    printf "Couldn't find a valid 'STAR' index...\n"
    printf "Please, build one using 'STAR ... --runMode genomeGenerate ...'\n"
    printf "and check the 'install.paths' file.\n"
    exit 9
fi
if [[ -z "${rsempath}" || ! -e "${rsempath}/rsem-calculate-expression" ]]; then
    printf "Couldn't find 'rsem-calculate-expression' executable...\n"
    printf "Please, check the 'install.paths' file.\n"
    exit 10
fi
if [[ -z "${rsemref_path}" || -z "$(find "$(dirname "${rsemref_path}")" \
    -maxdepth 1 -type f -iname "$(basename "${rsemref_path}*")" \
    2> /dev/null)" ]]; then
    printf "Couldn't find a valid 'RSEM' reference...\n"
    printf "Please, build one using 'rsem-prepare-reference'\n"
    printf "and check the 'install.paths' file.\n"
    exit 11
fi

# --- Main program -------------------------------------------------------------

# Prevent multiple STAR/RSEM instances
running_proc=$(pgrep -l "STAR|rsem-" | wc -l || [[ $? == 1 ]])
if [[ $running_proc -gt 0 ]]; then
    printf "\nSome instances of either STAR or RSEM are already running "
    printf "in the background!"
    printf "\nPlease kill them or wait for them to finish before running this "
    printf "script again...\n"
    exit 12 # Failure exit status: STAR/RSEM already running
fi

# Set the log file
# When creating the log file, 'basename "$target_dir"' assumes that DATADIR
# was properly named with the current BioProject/Study ID.
log_file="${target_dir}/Z_anqFASTQ_$(basename "$target_dir")_$(_tstamp).log"
_dual_log false "$log_file" "-- $(_tstamp) --"
_dual_log $verbose "$log_file" \
    "anqFASTQ :: x.FASTQ Wrapper for STAR and RSEM :: ver.${ver}\n"

# Set the warning login message
_set_motd "${xpath}/config/motd_warn" | tee -a "$log_file"

_dual_log $verbose "$log_file" \
    "STAR found in \"${starpath}\"" \
    "STAR index found in \"${starindex_path}\"" \
    "RSEM found in \"${rsempath}\"" \
    "RSEM reference found in \"$(dirname "${rsemref_path}")\"\n" \
    "Searching '${target_dir}' for FASTQs to align..."

# Select the proper library layout and prepare variables
if $paired_reads && $dual_files; then

    _dual_log $verbose "$log_file" "\nRunning in \"dual-file paired-end\" mode:"

    # Assign paired suffixes
    r_suffix="$(_explode_ORpattern "$suffix_pattern")"
    r1_suffix="$(echo "$r_suffix" | cut -d ',' -f 1)"
    r2_suffix="$(echo "$r_suffix" | cut -d ',' -f 2)"
    _dual_log $verbose "$log_file" \
        "   Suffix 1: ${r1_suffix}" \
        "   Suffix 2: ${r2_suffix}"

    extension=".*\.gz$"
    if [[ ! "$r_suffix" =~ $extension ]]; then
        _dual_log true "$log_file" \
            "\nFATAL: Only .gz-compressed FASTQs are currently supported!" \
            "Adapt '--readFilesCommand' option to handle different formats."
        exit 13 # Failure exit status: unsupported FASTQ format
    fi
    
    _check_fastq_pairing $verbose "$log_file" \
                         "$r1_suffix" "$r2_suffix" "$target_dir"

elif ! $paired_reads; then

    _dual_log $verbose "$log_file" \
        "\nRunning in \"single-ended\" mode:" \
        "   Suffix: ${se_suffix}"

    extension=".*\.gz$"
    if [[ ! "$se_suffix" =~ $extension ]]; then
        _dual_log true "$log_file" \
            "\nFATAL: Only .gz-compressed FASTQs are currently supported!" \
            "Adapt '--readFilesCommand' option to handle different formats."
        exit 16 # Argument failure exit status: missing DATADIR
    fi

    _check_fastq_unpaired $verbose "$log_file" "$se_suffix" "$target_dir"
    
elif ! $dual_files; then

    _dual_log true "$log_file" \
        "\nSTAR doesn't currently support PE interleaved FASTQ files." \
        "Check it out at https://github.com/alexdobin/STAR/issues/686" \
        "You can deinterlace them first and then run x.FASTQ in the" \
        "dual-file PE default mode. See, e.g.," \
        "\nPosts" \
        "  https://stackoverflow.com/questions/59633038/how-to-split-paired-end-fastq-files" \
        "  https://www.biostars.org/p/141256/" \
        "\ndeinterleave_fastq.sh on GitHub Gist" \
        "  https://gist.github.com/nathanhaigh/3521724" \
        "\nseqfu deinterleave" \
        "  https://telatin.github.io/seqfu2/tools/deinterleave.html"
        exit 18
fi

# Export variables needed by 'starsem' script (running in a subshell)
export	xpath paired_reads dual_files target_dir r1_suffix r2_suffix se_suffix \
        counter starpath starindex_path rsempath rsemref_path  remove_bam

# HOLD-ON STATEMENT
_hold_on "$log_file" "${xpath}/starsem.sh"
