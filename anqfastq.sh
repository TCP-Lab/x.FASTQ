#!/bin/bash

# ============================================================================ #
#  Align transcripts and quantify abundances using STAR and RSEM
# ============================================================================ #

# NOTE: this script calls itself recursively to add a leading 'nohup' and
#       trailing '&' to $0 in order to always run in background and persistent
#       mode. While everything seems to work fine, the structure of the process
#       is quite convoluted and is likely to be difficult to understand and
#       maintain, especially after some time. Consider rewriting the script
#       splitting it into 2 separate files along the lines of 'trimmer.sh' and
#       'trimfastq.sh', where the former is the basic script and the latter
#       calls the former by adding the nohup feature.

# --- General settings and variables -------------------------------------------

set -e # "exit-on-error" shell option
set -u # "no-unset" shell option

# Default options
ver="1.6.1"
verbose=true
verbose_external=true
progress_or_kill=false

# Make sure that the script is called with `nohup`
if [[ "${1:-""}" != "selfcall" ]]; then

	# This script has *not* been called recursively by itself...
	# ...so let's do it with nohup

	# Argument check: move up -p, -k, -q detection
	for arg in "$@"; do
		if [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
			verbose_external=false
		elif [[ "$arg" == "-p" || "$arg" == "--progress" \
			 || "$arg" == "-k" || "$arg" == "--kill" ]]; then
			progress_or_kill=true
		fi
	done

	# Get the last argument (i.e., FQPATH)
	target_dir="${!#}"

	# MAIN STATEMENT
	nohup "$0" "selfcall" -q $@ > "nohup.out" 2>&1 &

	# Allow time for 'nohup.out' to be created
	sleep 0.5
	# When in '--quiet' mode, 'anqfastq.sh' sends messages to the std output
	# (i.e., display on screen) only in the case of --help, --version, bad
	# arguments, exceptions, to show progress (when run with -p option) or
	# killed processes (when run with -k option). For this reason, only when
	# the 'nohup.out' file is empty, 'anqfastq.sh' is actually going to align
	# and quantify something (and so the head of the log is to be printed)...
	# Otherwise, just print 'nohup.out' to show the standard output and exit.
	# Thus, the code lines
	# 		_dual_log $verbose "$log_file"
	# when invoked under -q option, will send messages only to log file, whose
	# first 10 lines will be printed on screen by 'head -n 10 "$latest_log"' in
	# the case of no errors, while the code lines
	#		_dual_log true "$log_file"
	# will always send message to log AND to std out, resulting in a non-empty
	# 'nohup.out' file, that will be printed just before script termination.
	if [[ -s "nohup.out" ]]; then
		cat "nohup.out" # Retrieve error messages...
		rm "nohup.out"  # ...and clean
		exit 0 # Currently unable to tell whether this is successful or not...
	fi
	rm "nohup.out"

	# Print the head of the log file as a preview of the scheduled job
	if $verbose_external && (! $progress_or_kill); then

		# Allow time for the new log to be created and found
		sleep 0.5
		# NOTE: In the 'find' command below, the -printf "%T@ %p\n" option
		#       prints the modification timestamp followed by the filename.
		latest_log="$(find "${target_dir}" -maxdepth 1 -type f \
			-iname "Z_Quant_*.log" -printf "%T@ %p\n" \
			| sort -n | tail -n 1 | cut -d " " -f 2)"

		printf "\nHead of ${latest_log}\n"
		head -n 10 "$latest_log"
		printf "Start count computation through STAR/RSEM in background...\n"
	fi
	exit 0 # Success exit status
else
	# This script has been called recursively by itself (in nohup mode)
	shift # Remove the termination condition flag in $1
fi

# --- Function definition ------------------------------------------------------

# Default options
paired_reads=true
dual_files=true
remove_bam=true
suffix_pattern="(1|2).fastq.gz"
se_suffix=".fastq.gz"

# Source functions from x.funx.sh
# NOTE: 'realpath' expands symlinks by default. Thus, $xpath is always the real
#       installation path, even when this script is called by a symlink!
xpath="$(dirname "$(realpath "$0")")"
source "${xpath}"/x.funx.sh

# Print the help
function _help_anqfastq {
	echo
	echo "The anqFASTQ script (short for Align'n'Quantify FASTQs) is a wrapper"
	echo "for STAR aligner and RSEM quantifier. It analyzes multiple FASTQ"
	echo "files in sequence, using 'nohup' to persistently schedule a series of"
	echo "transcript alignment and abundance quantification operations that can"
	echo "be executed in the background on a remote machine. By design, only"
	echo "BAM (not SAM) files are generated by STAR and removed by default after"
	echo "each RSEM cycle."
	echo 
	echo "Usage:"
	echo "  anqfastq [-h | --help] [-v | --version]"
	echo "  anqfastq -p | --progress [FQPATH]"
	echo "  anqfastq -k | --kill"
	echo "  anqfastq [-q | --quiet] [-s | --single-end] [-i | --interleaved]"
	echo "           [-a | --keep-all] [--suffix=\"PATTERN\"] FQPATH"
	echo
	echo "Positional options:"
	echo "  -h | --help         Show this help."
	echo "  -v | --version      Show script's version."
	echo "  -p | --progress     Show alignment and quantification progress by"
	echo "                      printing the latest cycle of the latest (still"
	echo "                      possibly growing) log file. If FQPATH is not"
	echo "                      specified, search \$PWD for anqFASTQ logs."
	echo "  -k | --kill         Kill all the 'STAR' and 'RSEM' instances"
	echo "                      currently running and started by the current"
	echo "                      user (i.e., \$USER)."
	echo "  -q | --quiet        Disable verbose on-screen logging."
	echo "  -s | --single-end   Single-ended (SE) reads. NOTE: non-interleaved"
	echo "                      (i.e., dual-file) PE reads is the default."
	echo "  -i | --interleaved  PE reads interleaved into a single file."
	echo "                      Ignored when '-s' option is also present."
	echo "  -a | --keep-all     Do not delete BAM files after quantification"
	echo "                      (if you have infinite storage space...)."
	echo "  --suffix=\"PATTERN\"  For dual-file PE reads, \"PATTERN\" should be"
	echo "                      a regex-like pattern of this type"
	echo "                      \"leading_str(alt_1|alt_2)trailing_str\","
	echo "                      specifying the two alternative suffixes used to"
	echo "                      match paired FASTQs. The default pattern is"
	echo "                      \"${suffix_pattern}\"."
	echo "                      For SE reads or interleaved PE reads, it can be"
	echo "                      any text string, the default being"
	echo "                      \"${se_suffix}\"."
	echo "                      In any case, this option must be the last one"
	echo "                      of the flags, placed right before FQPATH."
	echo "  FQPATH              Path of a FASTQ-containing folder. The script"
	echo "                      assumes that all the FASTQs are in the same"
	echo "                      directory, but it doesn't inspect subfolders."
}

# Show alignment and quantification progress printing the tail of the latest log
function _progress_anqfastq {

	if [[ -d "$1" ]]; then
		target_dir="$1"
	else
		printf "Bad FQPATH '$1'.\n"
		exit 9 # Argument failure exit status: bad target path
	fi

	# NOTE: In the 'find' command below, the -printf "%T@ %p\n" option prints
	#       the modification timestamp followed by the filename.
	latest_log=$(find "${target_dir}" -maxdepth 1 -type f \
		-iname "Z_Quant_*.log" -printf "%T@ %p\n" \
		| sort -n | tail -n 1 | cut -d " " -f 2)

	if [[ -n "$latest_log" ]]; then
		
		echo -e "\n${latest_log}\n"

		# Print only the last cycle in the log file by finding the penultimate
		# occurrence of the pattern "============"
		line=$(grep -n "============" "$latest_log" | \
			cut -d ":" -f 1 | tail -n 2 | head -n 1)
		
		tail -n +${line} "$latest_log"      
		exit 0 # Success exit status
	else
		printf "No anqFASTQ log file found in '$(realpath "$target_dir")'.\n"
		exit 10 # Argument failure exit status: missing log
	fi
}

# --- Argument parsing ---------------------------------------------------------

# Flag Regex Pattern (FRP)
frp="^-{1,2}[a-zA-Z0-9-]+"
# Value Regex Pattern (VRP)
vrp="^.*\(.*\|.*\).*$"

# Argument check: options
while [[ $# -gt 0 ]]; do
	if [[ "$1" =~ $frp ]]; then
		case "$1" in
			-h | --help)
				_help_anqfastq
				exit 0 # Success exit status
			;;
			-v | --version)
				figlet a\'n\'q FASTQ
				printf "Ver.${ver} :: The Endothelion Project :: by FeAR\n"
				exit 0 # Success exit status
			;;
			-p | --progress)
				# Cryptic one-liner meaning "$2" or $PWD if argument 2 is unset
				_progress_anqfastq "${2:-.}"
			;;
			-k | --kill)
				k_flag="k_flag"
				while [[ -n "$k_flag" ]]; do
					k_flag="$(pkill -eu $USER "STAR" || [[ $? == 1 ]])"
					if [[ -n "$k_flag" ]]; then echo "$k_flag"; fi
				done
				k_flag="k_flag"
				while [[ -n "$k_flag" ]]; do
					k_flag="$(pkill -eu $USER "rsem-" \
						|| [[ $? == 1 ]])"
					if [[ -n "$k_flag" ]]; then echo "$k_flag"; fi
				done
				if [[ -e ~/motd ]]; then
					cp ~/motd /etc/motd
					rm ~/motd
				fi
				exit 0
			;;
			-q | --quiet)
				verbose=false
				shift
			;;
			-s | --single-end)
				paired_reads=false
				shift
			;;
			-i | --interleaved)
				dual_files=false
				shift
			;;
			-a | --keep-all)
				remove_bam=false
				shift  
			;;
			--suffix*)
				# Test for '=' presence
				rgx="^--suffix="
				if [[ "$1" =~ $rgx ]]; then

					if [[ $paired_reads == true && $dual_files == true && \
					   "${1/--suffix=/}" =~ $vrp ]]; then
						
						suffix_pattern="${1/--suffix=/}"
						shift

					elif [[ ($paired_reads == false || \
					   $dual_files == false) && "${1/--suffix=/}" != "" ]]; then

						se_suffix="${1/--suffix=/}"
						shift

					else
						printf "Bad suffix pattern.\n"
						printf "Values assigned to '--suffix' must have the "
						printf "following structure:\n\n"
						printf " - Non interleaved paired-end reads:\n"
						printf "   \"leading_str(alt_1|alt_2)trailing_str\"\n\n"
						printf " - Single-ended/interleaved paired-end reads:\n"
						printf "   \"any_nonEmpty_str\"\n"
						exit 1 # Bad suffix pattern format
					fi
				else
					printf "Values need to be assigned to '--suffix' option "
					printf "using the '=' operator.\n"
					printf "Use '--help' or '-h' to see the correct syntax.\n"
					exit 2 # Bad suffix assignment
				fi
			;;
			*)
				printf "Unrecognized option flag '$1'.\n"
				printf "Use '--help' or '-h' to see possible options.\n"
				exit 3 # Argument failure exit status: bad flag
			;;
		esac
	else
		# The first non-FRP sequence is taken as the FQPATH argument
		target_dir="$1"
		break
	fi
done

# Argument check: FQPATH target directory
if [[ -z "${target_dir:-""}" ]]; then
	printf "Missing option or FQPATH argument.\n"
	printf "Use '--help' or '-h' to see the expected syntax.\n"
	exit 4 # Argument failure exit status: missing FQPATH
elif [[ ! -d "$target_dir" ]]; then
	printf "Invalid target directory '$target_dir'.\n"
	exit 5 # Argument failure exit status: invalid FQPATH
fi

# Retrieve STAR and RSEM local paths from the 'install_paths.txt' file
starpath="$(grep -i "$(hostname):STAR:" "${xpath}/install_paths.txt" \
	| cut -d ':' -f 3)"
starindex_path="$(grep -i "$(hostname):S_index:" "${xpath}/install_paths.txt" \
	| cut -d ':' -f 3)"
rsempath="$(grep -i "$(hostname):RSEM:" "${xpath}/install_paths.txt" \
	| cut -d ':' -f 3)"
rsemref_path="$(grep -i "$(hostname):R_ref:" "${xpath}/install_paths.txt" \
	| cut -d ':' -f 3)"

if [[ ! -f "${starpath}/STAR" ]]; then
	printf "Couldn't find 'STAR' executable...\n"
	printf "Please, check the 'install_paths.txt' file.\n"
	exit 11
fi
if [[ ! -f "${starindex_path}/SA" ]]; then
	printf "Couldn't find a valid 'STAR' index...\n"
	printf "Please, build one using 'STAR ... --runMode genomeGenerate ...'.\n"
	exit 12
fi

# --- Main program -------------------------------------------------------------

target_dir="$(realpath "$target_dir")"
log_file="${target_dir}"/Z_Quant_"$(basename "$target_dir")"_$(_tstamp).log

# Set the warning login message
if [[ -e /etc/motd ]]; then
	if [[ -w /etc/motd ]]; then
		cp /etc/motd ~
		cp "${xpath}/warning_motd" /etc/motd
	else
		_dual_log $verbose "$log_file" "\n\
			Cannot change the Message Of The Day...
			Current user has no write access to '/etc/motd'.
			Consider 'sudo chmod 666 /etc/motd'"
	fi
else
	_dual_log $verbose "$log_file" "\n\
		Cannot change the Message Of The Day...
		'/etc/motd' file not found.
		Consider 'sudo touch /etc/motd; sudo chmod 666 /etc/motd'"
fi

_dual_log $verbose "$log_file" "\n\
	STAR found in \"${starpath}\"
	STAR index found in \"${starindex_path}\"\n
	Searching ${target_dir} for FASTQs to align..."

if $paired_reads && $dual_files; then

	_dual_log $verbose "$log_file" \
		"\nRunning in \"dual-file paired-end\" mode:"

	# Assign the suffixes to match paired FASTQs
	r_suffix="$(_explode_ORpattern "$suffix_pattern")"
	r1_suffix="$(echo "$r_suffix" | cut -d ',' -f 1)"
	r2_suffix="$(echo "$r_suffix" | cut -d ',' -f 2)"
	_dual_log $verbose "$log_file" "\
		   Suffix 1: ${r1_suffix}\n\
		   Suffix 2: ${r2_suffix}"

	extension=".*\.gz$"
	if [[ ! "$r_suffix" =~ $extension ]]; then
		_dual_log true "$log_file" \
			"FATAL: Only .gz-compressed FASTQs are currently supported!
			Adapt '--readFilesCommand' option to handle different formats."
		exit 13 # Argument failure exit status: missing FQPATH
	fi

	# Check FASTQ pairing
	counter=0
	while IFS= read -r line
	do
		if [[ ! -e "${line}${r1_suffix}" || ! -e "${line}${r2_suffix}" ]]; then
			_dual_log true "$log_file" "\n\
				A FASTQ file is missing in the following pair:\n\
				   ${line}${r1_suffix}\n\
				   ${line}${r2_suffix}\n\n\
				Aborting..."
			exit 6 # Argument failure exit status: incomplete pair
		else
			counter=$((counter+1))
		fi
	done <<< $(find "$target_dir" -maxdepth 1 -type f \
				-iname "*$r1_suffix" -o -iname "*$r2_suffix" \
				| sed -E "s/(${r1_suffix}|${r2_suffix})//" | sort -u)
	# NOTE:
	# A 'here-string' is used here because if the 'while read' loop had been
	# piped in this way
	#
	# find ... | sed ... | sort -u | while IFS= read -r line; do ... done
	#
	# the 'counter' variable would have lost its value at end of the while loop.
	# This is because pipes create SubShells, which would have made the loop
	# run on a different shell than the script. Since pipes spawn additional
	# shells, any variable you mess with in a pipe will go out of scope as soon
	# as the pipe ends!

	_dual_log $verbose "$log_file" \
		"$counter x 2 = $((counter*2)) paired FASTQ files found."

	# Loop over them
	i=1 # Just another counter
	for r1_infile in "${target_dir}"/*"$r1_suffix"
	do
		r2_infile=$(echo "$r1_infile" | sed "s/$r1_suffix/$r2_suffix/")

		_dual_log $verbose "$log_file" "\n\
			============\n\
			 Cycle ${i}/${counter}\n\
			============\n\
			Targeting: ${r1_infile}\n\
			           ${r2_infile}"

		r1_length=$(_mean_read_length "$r1_infile")
		r2_length=$(_mean_read_length "$r2_infile")
		_dual_log $verbose "$log_file" "\n\
			Estimated (ceiling) mean read length: \
			${r1_length} + ${r2_length} bp"
		if [[ $r1_length -lt 50 || $r2_length -lt 50 ]]; then
			_dual_log $verbose "$log_file" "\
				WARNING: Mean read length less than 50 bp !!\n\
				If using a \"standard\" STAR index \
				(i.e., '--sjdbOverhang 100'),\n\
				consider to build another one using '--sjdbOverhang \
				$(( r1_length < r2_length ? r1_length-1 : r2_length-1 ))'"
		fi

		prefix="$(basename "$r1_infile" | grep -oP "^[a-zA-Z]*\d+")"
		out_dir="${target_dir}/Counts/${prefix}"
		mkdir -p "$out_dir"

		# Run STAR
		_dual_log $verbose "$log_file" \
			"\nStart aligning through STAR...\n"
		# also try to add this to use shared memory: --genomeLoad LoadAndKeep \
		${starpath}/STAR \
			--runThreadN 8 \
			--runMode alignReads \
			--quantMode TranscriptomeSAM \
			--outSAMtype BAM Unsorted \
			--genomeDir "$starindex_path" \
			--readFilesIn "$r1_infile" "$r2_infile" \
			--readFilesCommand gunzip -c \
			--outFileNamePrefix "${out_dir}/STAR." \
			>> "${log_file}" 2>&1

		# Run RSEM
		_dual_log $verbose "$log_file" \
			"\nStart quantification through RSEM...\n"
		${rsempath}/rsem-calculate-expression \
			-p 8 \
			--alignments \
			--paired-end \
			--no-bam-output \
			--append-names \
			"${out_dir}/STAR.Aligned.toTranscriptome.out.bam" \
			"${rsemref_path}" \
			"${out_dir}/RSEM" \
			>> "${log_file}" 2>&1

		_dual_log $verbose "$log_file" "DONE!"

		# Remove BAM files generated by STAR
		if $remove_bam; then
			rm "${out_dir}"/*.bam
		fi

		# Increment the i counter
		((i++))
	done

elif ! $paired_reads; then

	echo -e "\n${red}Just written, never tested... please, debug first!${end}"
	exit 17

	_dual_log $verbose "$log_file" "\n\
		Running in \"single-ended\" mode:\n\
		   Suffix: ${se_suffix}"

	extension=".*\.gz$"
	if [[ ! "$se_suffix" =~ $extension ]]; then
		_dual_log true "$log_file" \
			"FATAL: Only .gz-compressed FASTQs are currently supported!
			Adapt '--readFilesCommand' option to handle different formats."
		exit 13 # Argument failure exit status: missing FQPATH
	fi

	counter=$(ls "${target_dir}"/*"$se_suffix" | wc -l)

	if (( counter > 0 )); then
		_dual_log $verbose "$log_file" "\n\
			$counter single-ended FASTQ files found."
	else
		_dual_log true "$log_file" \
			"\nThere are no FASTQ files ending with \"${se_suffix}\" \
			in ${target_dir}."
		exit 7 # Argument failure exit status: no FASTQ found
	fi

	# Loop over them
	i=1 # Just another counter
	for infile in "${target_dir}"/*"$se_suffix"
	do
		_dual_log $verbose "$log_file" "\n\
			============\n\
			 Cycle ${i}/${counter}\n\
			============\n\
			Targeting: ${infile}"

		r_length=$(_mean_read_length "$infile")
		_dual_log $verbose "$log_file" \
			"\nEstimated (ceiling) mean read length: ${r_length} bp"
		if [[ $r_length -lt 50 ]]; then
			_dual_log $verbose "$log_file" "\
				WARNING: Mean read length less than 50 bp !!\n\
				If using a \"standard\" STAR index \
				(i.e., '--sjdbOverhang 100'),\n\
				consider to build another one using '--sjdbOverhang \
				$(( r_length-1 ))'"
		fi

		prefix="$(basename "$infile" | grep -oP "^[a-zA-Z]*\d+")"
		out_dir="${target_dir}/Counts/${prefix}"
		mkdir -p "$out_dir"

		# Run STAR
		_dual_log $verbose "$log_file" \
			"\nStart aligning through STAR...\n"
		# also try to add this to use shared memory: --genomeLoad LoadAndKeep \
		${starpath}/STAR \
			--runThreadN 8 \
			--runMode alignReads \
			--quantMode TranscriptomeSAM \
			--outSAMtype BAM Unsorted \
			--genomeDir "$starindex_path" \
			--readFilesIn "$infile" \
			--readFilesCommand gunzip -c \
			--outFileNamePrefix "${out_dir}/STAR." \
			>> "${log_file}" 2>&1

		# Run RSEM
		_dual_log $verbose "$log_file" "\n\
			WARNING: no information available about the length of the fragments!
			         RSEM will run in single-end mode without considering \
			fragment length distribution.
			         See the 'README.md' file for a discussion about the \
			implication of this."
		_dual_log $verbose "$log_file" \
			"\nStart quantification through RSEM...\n"
		${rsempath}/rsem-calculate-expression \
			-p 8 \
			--alignments \
			--no-bam-output \
			--append-names \
			"${out_dir}/STAR.Aligned.toTranscriptome.out.bam" \
			"${rsemref_path}" \
			"${out_dir}/RSEM" \
			>> "${log_file}" 2>&1

		_dual_log $verbose "$log_file" "DONE!"

		# Remove BAM files generated by STAR
		if $remove_bam; then
			rm "${out_dir}"/*.bam
		fi

		# Increment the i counter
		((i++))
	done

elif ! $dual_files; then

	_dual_log true "$log_file" "\n\
		STAR doesn't currently support PE interleaved FASTQ files.
		Check it out at https://github.com/alexdobin/STAR/issues/686
		You can deinterlace them first and then run x.FASTQ in the
		dual-file PE default mode. See, e.g.,
		\nPosts
		   https://stackoverflow.com/questions/59633038/how-to-split-paired-end-fastq-files
		   https://www.biostars.org/p/141256/
		\ndeinterleave_fastq.sh on GitHub Gist
		   https://gist.github.com/nathanhaigh/3521724
		\nseqfu deinterleave
		   https://telatin.github.io/seqfu2/tools/deinterleave.html"
fi

# Restore previous login message status
if [[ -e ~/motd ]]; then
	cp ~/motd /etc/motd
	rm ~/motd
fi
